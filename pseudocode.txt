CLASS Deck:
    SET availableCards TO []
    SET cutCards TO []
    SET spentCards TO []

    METHOD CreateDeck(decks)
        SET decks TO decks * 4
        FOR iter1 FROM 0 TO decks DO
            FOR iter2 FROM 0 TO 13 DO
                APPEND [iter1, iter2] TO availableCards
            END FOR
        END FOR
    END METHOD

    METHOD shuffle()
        SET length TO length(availableCards)
        
        WHILE length > 0 DO
            SET length TO length - 1
            SET selectedCard TO Round(RandomInt * length)

            SET temp TO availableCards[length]
            SET availableCards[length] TO availableCards[selectedCard]
            SET availableCards[selectedCard] TO temp
        END WHILE
    END METHOD

    METHOD cut()
        #cut 20% of the deck which is 62 cards
        FOR iterA FROM 0 TO 62 DO
            APPEND availableCards[iterA] TO cutCards
            REMOVE availableCards[iterA]
        END FOR
    END METHOD

    METHOD deal()
        FOR EACH iterB FROM Players DO
            APPEND availableCards[2 LAST] TO Players[iterB]
        END FOR
    END METHOD
    
    METHOD hit() 
        return availableCards.pop()
    END METHOD
    
    METHOD return(cards) 
        PUSH cards TO spentCards
    END METHOD
    
    METHOD combineDecks()
        FOR iter3 Length(cutCards)
            APPEND cutCards TO availableCards
        END FOR
        FOR iter4 TO Length(spendCards)
           APPEND spentCards TO availableCards
        END FOR
    END METHOD
    
    METHOD store()
        WRITE {
            availableCards, availableCards
            cutCards, cutCards
            spentCards, spentCards
        }  TO FILE
    END METHOD
END CLASS
    
CLASS dealer:
    SET cards TO []
    SET players TO 2
    
    METHOD display()
        FOR EACH card FROM cards
            SWITCH cards[1]:
                0:  SET suit TO 'A'
                1:  SET suit TO 'B'
                2:  SET suit TO 'C'
                3:  SET suit TO 'D'
            END SWITCH

            SET cardVal TO card[1] + 1 TO HEXADECIMAL
            SET temp TO "0x0001F0" & suit & cardVal
            RETURN temp TO UNICODE;
        END FOR    
    END METHOD
    
    METHOD evaluate()
        SET value TO 0
        FOR iterC FROM 0 TO length CARDS
            SWITCH cards[iterC][1]:
                0:
                    value += 1
                1,2,3,4,5,6,7,8,9:
                    value += cards[1] + 1
                10,11,12:
                    value += 10
            END SWITCH
        END FOR
        RETURN value
    END METHOD    
    
    METHOD stand()
        turn = false 
    END METHOD
    
    METHOD hit()
        APPEND deck.hit() TO cards
    END METHOD
    
    METHOD return()
        Deck.return(cards)
        SET cards TO []
    METHOD
    
    METHOD store()
        WRITE {
            i & cards, cards
            i & players, players
        }  TO FILE
    END METHOD
END CLASS
    
CLASS AIhand INHERITS dealer:
    SET bank TO 5000
    SET balance TO Math.random()
    
    METHOD wager()
        SET wager TO Random(0,1,2)
    END METHOD
    
    METHOD store(i)
        WRITE {
            i & cards, cards
            i & bank, bank
            i & balance, balance
        }  TO FILE
    END METHOD
END CLASS

CLASS playerHand INHERITS dealer:
    SET bank TO 5000
    SET wager TO 50
    SET splitCards TO []
    SET handle TO ""
    
    METHOD display()
        FOR EACH card FROM cards
            RETURN unicodeCards[cards[card][0] MOD 4, cards[card][1]]
        END FOR    
        IF splitCards != null
            RETURN unicodeCards[splitCards[card][0] MOD 4, splitCards[card][1]]
        END IF
    END METHOD

    METHOD double()
        APPEND deck.hit() TO cards
        SET turn TO FALSE
    END METHOD

    METHOD splitCards()
        APPEND cards.pop TO splitCards
    END METHOD
    
    METHOD store(i)
        WRITE {
            i & cards, cards
            i & bank, bank
            i & wager, wager
            i & splitCards, splitCards
            i & handle, handle
        }  TO FILE
    END METHOD
END CLASS

                # MAIN PROGRAM  #
SET deck TO NEW deck
SET Dealer TO NEW dealer
SET Player TO NEW playerHand
SET Players TO [] 
APPEND dealer TO Players

FUNCTION Round():    
    deck.deal()
    
    FOR EACH iterG FROM Players DO
        Players[iterG].store(iterG)
    END FOR
    
    deck.store()

    FOR iterD FROM 1 TO Length(Players) - 1 DO
        WHILE Players[iterD].turn IS True Then
            IF Players[iterD].evaluate() > Players[iterD].balance THEN
                Players[iterD].hit()
            ELSE
                Players[iterD].stand()
            END IF
        END WHILE
    END FOR
    
    SET display TO ROUND DOWN (LENGTH Players / 2)
    FOR iterE FROM 1 TO display + 1 DO
        Players[iterE].display()
    END FOR
    
    turn = true
    WHILE turn
        SWITCH input:
            hit:
                Player[length(Player) - 1].hit()
            stand:
                Player[length(Player) - 1].stand()
            double:
                Player[length(Player) - 1].double()
            split:
                Player[length(Player) - 1].split()
        END SWITCH
    END WHILE
    
    FOR iterF FROM 1 TO Length(Players) DO
        #if lower than dealer or over 21
        IF Players[iterF].evaluate < Players[0].evaluate OR Players[iterF] >= 21 THEN
            SET Players[iterF].bank TO Players[iterF].bank - Players[iterF].wager
        #if higher than dealer
        ELSE IF Players[iterF].evaluate > Players[0].evaluate THEN
            SET Players[iterF].bank TO Players[iterF].bank + Players[iterF].wager
        ELSE
            #tied, do nothing
        END IF    
    END FOR
    
    FOR EACH iterG FROM Players DO
        Players[iterG].store()
    END FOR    
END FUNCTION

FUNCTION newGame():  
    SET deck.players TO INT FROM GUI
    FOR iterH FROM 0 TO deck.players DO
        SET player & iterH TO NEW AIhand
        APPEND player & iterH TO Players
    END FOR

    APPEND Player TO Players

    deck.CreateDeck(6)
    deck.shuffle()
    deck.cut()
    
    WHILE playing:
        IF Length(deck.availableCards) > 4 * Length(Players)
            Round();
        ELSE
            deck.combineDecks()
            deck.shuffle()
            deck.cut()
        END IF
    END WHILE
END FUNCTION

FUNCTION loadGame():
    SET deck.availableCards TO READ FILE availableCards
    SET deck.cutCards TO READ FILE cutCards
    SET deck.spentCards TO READ FILE spentCards
    SET deck.players TO READ FILE players
    
    SET Players[0].cards TO READ FILE 0cards
    
    FOR iterI FROM 1 TO Length(Players) + 1
        SET Players[iterI].cards TO READ FILE iterI & cards
        SET Players[iterI].bank TO READ FILE iterI & bank
        SET Players[iterI].balance TO READ FILE iterI & cards
        
        IF iterI IS Length(Players)
            SET Players[iterI].wager TO READ FILE iterI & wager
            SET Players[iterI].splitCards TO READ FILE iterI & splitCards
            SET Players[iterI].handle TO READ FILE iterI & handle/
        END IF
    END FOR
END FUNCTION

FUNCTION tournament():
    APPEND Player TO Players
    SET Player.handle TO USER INPUT

    deck.CreateDeck(6)
    deck.shuffle()
    deck.cut()
    
    FOR iterJ FROM 0 TO 10:
        Round();
        iterJ++
    END FOR
    
    # SORT #
    SET currentval TO Player.bank    
	SET position TO 1   
	WHILE position > 0 AND list[position-1] > currentval     
		list[position] = list[position-1]        
		position -= 1    
	END WHILE
    SET list[position] = currentval
END FUNCTION
